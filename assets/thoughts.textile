h1. Some thoughts on nanosome.flow

* itâ€™s a state machine not for components themselves, but for certain attributes of its properties.
* aim is to provide visual consistency and fluid, smooth experience
* animation is updating every frame, because its all about visuals

* @StateMachine@ - this state machine has states and transitions, but lacks @TransitionConditions@ required for triggering them. 
* @Transitions@ has no durations.
* @VisualStateMachine@ - its a @StateMachine@ with @TransitionCondtitions@ and with transition durations.
* @StateMachineVisualizer@

h2. State machine creation and configuration

Old architecture was based on "one logic - many states". 
Like

bc. 
simpleSMLogic = new StateMachineLogic();
... configure logic ...
fwdButton.stateMachine = new StateMachine(simpleSMLogic);
bwdButton.stateMachine = new StateMachine(simpleSMLogic);

SMLogic was supposed to be configured once and reused afterwards. Although, this approach is faulty in linking SMLogic and SM itself - each time we need to copy a bunch of logic from SMLogic to SM. I guess, it is solvable, but in this case code will became unnecessary complicated.

Alternative solution was suggested by Martin, and it seems to be very cool and type safe.

StateMachine configuration should be moved to factory:

bc. 
public interface ISimpleButton
{
	function pressed():BindableBoolean;
	function overed():BindableBoolean;
	function setStateMachine(value:StateMachine):void
}
public class SimpleSMFactory
{
  public static function configureSM(button:ISimpleButton):void
  {
  	  var sm:StateMachine = new StateMachine();
	  sm.addStates("normal", "overed", "pressed", "pressedOutside");
	  sm.from("normal").on(button.overed).to("overed").andBack();
	  sm.from("overed").on(button.pressed).to("pressed").andBack();
	  sm.from("pressed").on(button.overed.not).to("pressedOutised");
	  button.setStateMachine(sm);
  }
}
public function myMethod():void
{
  fwdButton.stateMachine = SimpleSMFactory.configure(fwdButton);
  bwdButton.stateMachine = SimpleSMFactory.configure(bwdButton);
}

SimpleFactory

We can use two approaches in linking chain _Object - Transition Condition - Transition - State_. First is to group Object with Transition conditions within Element, and Transitions with States within StateMachine. That means each Element should define his own Transition Conditions and pass them to the State Machine:

bc. private function onMouseMove(overed:Boolean):void
{
    _backSM.setCondition("isOvered", overed);
    _iconSM.setCondition("isOvered", overed);
}

This code is relatively safe (nothing bad will happen if we will send incorrect signal name), and it does not require SM to check condition itself. 

Other approach is a little bit more tricky - we're grouping Transition condition with StateMachine, and passing Element as context:

bc. 
_backSM.addCondition("isOvered", function(o:Object):Boolean { return o.isOvered; });
_backSM.setContext(this);

bc. 
private function onMouseMove():void
{
    _backSM.invalidate();
}

Alternative way would be using bindable variables, like IFields from nanosome.bind:

bc. 
var isOvered:Field;
_backSM.setCondition("isOvered", isOvered);

bc. private function onMouseMove(overed:Boolean):void
{
    isOvered.value= overed;
}

h2. Implementation Details

h3. Stage 1: Logic definition

bc. 
var _backSMLogic = new StateMachineLogic();

_backSM

TODO: State Machine logic definition

h3. Stage 2: Creating State Machine from logic

h3. Stage 3: Creating State Machine Visualizers

h3. Stage 4: Wiring conditions and visualizers

bc. 
var isOvered:Field;
var isPressed:Field;
_backSM = new StateMachine(backSMLogic);
// we should wire all conditions first
_backSM.defineCondition("overed", isOvered);
_backSM.defineCondition("pressed", isPressed);
// now adding visualizers, if added before condition 
// definitions, error will be thrown
_backSM.addVisualizer(_iconBackSMVisualizer);


h2. Miscellaneous

%{color:red}*Important:*% We have to animate with timings (see GoASAP for reference), not with enterFrame event
