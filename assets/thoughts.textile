h1. Some thoughts on nanosome.fluid

* itâ€™s a state machine not for components themselves, but for certain attributes of its properties.
* aim is to provide visual consistency and fluid, smooth experience
* animation is updating every frame, because its all about visuals

* @StateMachine@ - this state machine has states and transitions, but lacks @TransitionConditions@ required for triggering them. 
* @Transitions@ has no durations.
* @VisualStateMachine@ - its a @StateMachine@ with @TransitionCondtitions@ and with transition durations.
* @StateMachineVisualizer@

h2. Linking subject and state machine 

We can use two approaches in linking chain _Object - Transition Condition - Transition - State_. First is to group Object with Transition conditions within Element, and Transitions with States within StateMachine. That means each Element should define his own Transition Conditions and pass them to the State Machine:

bc. private function onMouseMove(overed:Boolean):void
{
    _backSM.setCondition("isOvered", overed);
    _iconSM.setCondition("isOvered", overed);
}

This code is relatively safe (nothing bad will happen if we will send incorrect signal name), and it does not require SM to check condition itself. 

Other approach is a little bit more tricky - we're grouping Transition condition with StateMachine, and passing Element as context:

bc. 
_backSM.addCondition("isOvered", function(o:Object):Boolean { return o.isOvered; });
_backSM.setContext(this);

bc. 
private function onMouseMove():void
{
    _backSM.invalidate();
}

Alternative way would be using bindable variables, like IFields from nanosome.bind:

bc. 
var isOvered:Field;
_backSM.setCondition("isOvered", isOvered);

bc. private function onMouseMove(overed:Boolean):void
{
    isOvered.value= overed;
}

h2. Implementation Details

h3. Stage 1: Logic definition

bc. 
var _backSMLogic = new StateMachineLogic();

_backSM

TODO: State Machine logic definition

h3. Stage 2: Creating State Machine from logic

h3. Stage 3: Creating State Machine Visualizers

h3. Stage 4: Wiring conditions and visualizers

bc. 
var isOvered:Field;
var isPressed:Field;
_backSM = new StateMachine(backSMLogic);
// we should wire all conditions first
_backSM.defineCondition("overed", isOvered);
_backSM.defineCondition("pressed", isPressed);
// now adding visualizers, if added before condition 
// definitions, error will be thrown
_backSM.addVisualizer(_iconBackSMVisualizer);


h2. Miscellaneous

%{color:red}*Important:*% We have to animate with timings (see GoASAP for reference), not with enterFrame event
