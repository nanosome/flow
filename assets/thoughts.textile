h1. Some thoughts on nanosome.flow

* itâ€™s a state machine not for components themselves, but for certain attributes of its properties.
* aim is to provide visual consistency and fluid, smooth experience
* animation is updating every frame, because its all about visuals

h2. State machine creation and configuration

State machine has a set of states, state transitions and state conditions. Transitions has no duration. With plain Fluid, regular functions are used for state conditions:   

bc. public interface ISimpleButton
{
	function isPressed():Boolean;
	function isOvered():Boolean;
	function setStateMachine(value:StateMachine):void
}
 
Although, in this case after every event (pressing or overing) we have to invoke StateMachine.invalidate to re-check all conditions. To avoid this, using nanosome.bind is recommended:

bc. public interface INanoSimpleButton
{
	function pressed():BindableBoolean;
	function overed():BindableBoolean;
	function setStateMachine(value:StateMachine):void
}

Recommended (and kinda obvious) way to configure StateMachine is a Factory pattern:

bc. public class SimpleSMFactory
{
  public static function configureSM(button:ISimpleButton):void
  {
  	  var sm:StateMachine = new StateMachine();
	  // sm.addStates("normal", "overed", "pressed", "pressedOutside"); // can be skipped
	  sm.from("normal").on(button.overed).to("overed").andBack();
	  sm.from("overed").on(button.pressed).to("pressed").andBack();
	  sm.from("pressed").on(button.overed.not).to("pressedOutside");
	  button.setStateMachine(sm);
  }
}
public function myMethod():void
{
  fwdButton.stateMachine = SimpleSMFactory.configure(fwdButton);
  bwdButton.stateMachine = SimpleSMFactory.configure(bwdButton);
}


h2. State machine visualizing

The core difference of StateMachine visualizer from StateMachine itself is having duration for transitions. Each StateMachine may have several visualizers, each visualizer is acting independently, trying to achieve same state StateMachine currently in. Thus, some visualizers may be very quick, other may have inert feel and slow. 

bc. 
var sm:StateMachine = getStateMachine();
var backVis:IStateMachineVisualizer = getVisualizerForBack(sm);
var iconVis:IStateMachineVisualizer = getVisualizerForIcon(sm);

Because of visualizers having durations for transitions, they can't be fully in sync with StateMachine, its more like "following to" StateMachine's state. 

h3. Visualizer's architecture

There's specific hierarchy in visualizer's structure. Each transition has exactly one duration. Each duration have at least one easing function. Each easing function has at least one related values set. Each values set has exactly one associated item transform.

First of all, let's define, what will be visualized by declaring item transforms: 

bc. 
var iconScaleTransform:IItemTransform = new ScaleTransform(_icon, {normal: 1, overed: 1.1, pressed: .8, pressedOutside: 1}); 
var iconAlphaTransform:IItemTransform = new AlphaTransform(_icon, {normal: .3, overed: .7, pressed: 1, pressedOutside: .8});
var iconColorTransform:IItemTransform = new ColorTransform(_icon, {normal: 0xFFFFFF, overed: 0xFF0000, pressed: 0x660000, pressedOutside: 0x666666});

After then, we can define durations and easings for StateMachine transitions, and link those easings to item transforms: 

bc. 
vis.defineTransitions({
	normalToOvered: 
	{	duration: 10,
		easing: Linear.easeOut,
		transform: [iconScaleTransform, iconAlphaTransform, iconColorTransform] // one easing, three transforms
	}, 	
	overedToNormal:
	{	duration: 10, 
		easing:  // two easings, three transforms
		[
			{	easing: Cubic.easeIn,
				transform: iconScaleTransform
			},
			{	easing: Linear.easeIn,
				transform: [iconAlphaTransform, iconColorTransform]
			}
		]
	});

In the end, we're linking visualizer to the StateMachine:

bc. 
vis.linkTo(sm);

At this point, visualizer is parsed to be valid and joinable to this state machine (all states and transitions are defined, etc), if something is wrong, error message will be thrown.

h3. Reversing transition

Initial state: A, second state B.

Reversing transition is required when state machine is switching back to its state A from B when visualizing to B is not over. In this case, intersection point of incoming and outcoming easing functions will be found and used as a starting point for outcoming easing.

*TODO: Example?* 

h3. Switching between transitions

Initial state: A, second state B, third state C.

Switching transition is required when state machine is switching to C when visualizing to B is not yet complete. In this case, starting point for easing is not value at B, but current value. Easing function and duration will remain the same (for "B to C" transition).

*TODO: Example?* 

h2. Miscellaneous

%{color:red}*Important:*% We have to animate with timings (see GoASAP for reference), not with enterFrame event
